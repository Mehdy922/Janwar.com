{"ast":null,"code":"import { createContext, useRef, useEffect, useContext, useState } from 'react';\nimport matchMedia from 'matchmediaquery';\nimport hyphenate from 'hyphenate-style-name';\nimport { shallowEqualObjects } from 'shallow-equal';\nimport PropTypes from 'prop-types';\nconst stringOrNumber = PropTypes.oneOfType([PropTypes.string, PropTypes.number]);\n// media types\nconst types = {\n  all: PropTypes.bool,\n  grid: PropTypes.bool,\n  aural: PropTypes.bool,\n  braille: PropTypes.bool,\n  handheld: PropTypes.bool,\n  print: PropTypes.bool,\n  projection: PropTypes.bool,\n  screen: PropTypes.bool,\n  tty: PropTypes.bool,\n  tv: PropTypes.bool,\n  embossed: PropTypes.bool\n};\n// properties that match media queries\nconst matchers = {\n  orientation: PropTypes.oneOf(['portrait', 'landscape']),\n  scan: PropTypes.oneOf(['progressive', 'interlace']),\n  aspectRatio: PropTypes.string,\n  deviceAspectRatio: PropTypes.string,\n  height: stringOrNumber,\n  deviceHeight: stringOrNumber,\n  width: stringOrNumber,\n  deviceWidth: stringOrNumber,\n  color: PropTypes.bool,\n  colorIndex: PropTypes.bool,\n  monochrome: PropTypes.bool,\n  resolution: stringOrNumber,\n  type: Object.keys(types)\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst {\n  type,\n  ...featureMatchers\n} = matchers;\n// media features\nconst features = {\n  minAspectRatio: PropTypes.string,\n  maxAspectRatio: PropTypes.string,\n  minDeviceAspectRatio: PropTypes.string,\n  maxDeviceAspectRatio: PropTypes.string,\n  minHeight: stringOrNumber,\n  maxHeight: stringOrNumber,\n  minDeviceHeight: stringOrNumber,\n  maxDeviceHeight: stringOrNumber,\n  minWidth: stringOrNumber,\n  maxWidth: stringOrNumber,\n  minDeviceWidth: stringOrNumber,\n  maxDeviceWidth: stringOrNumber,\n  minColor: PropTypes.number,\n  maxColor: PropTypes.number,\n  minColorIndex: PropTypes.number,\n  maxColorIndex: PropTypes.number,\n  minMonochrome: PropTypes.number,\n  maxMonochrome: PropTypes.number,\n  minResolution: stringOrNumber,\n  maxResolution: stringOrNumber,\n  ...featureMatchers\n};\nconst all = {\n  ...types,\n  ...features\n};\nvar mq = {\n  all: all,\n  types: types,\n  matchers: matchers,\n  features: features\n};\nconst negate = cond => `not ${cond}`;\nconst keyVal = (k, v) => {\n  const realKey = hyphenate(k);\n  // px shorthand\n  if (typeof v === 'number') {\n    v = `${v}px`;\n  }\n  if (v === true) {\n    return realKey;\n  }\n  if (v === false) {\n    return negate(realKey);\n  }\n  return `(${realKey}: ${v})`;\n};\nconst join = conds => conds.join(' and ');\nconst toQuery = obj => {\n  const rules = [];\n  Object.keys(mq.all).forEach(k => {\n    const v = obj[k];\n    if (v != null) {\n      rules.push(keyVal(k, v));\n    }\n  });\n  return join(rules);\n};\nconst Context = createContext(undefined);\nconst makeQuery = settings => settings.query || toQuery(settings);\nconst hyphenateKeys = obj => {\n  if (!obj) return undefined;\n  const keys = Object.keys(obj);\n  return keys.reduce((result, key) => {\n    result[hyphenate(key)] = obj[key];\n    return result;\n  }, {});\n};\nconst useIsUpdate = () => {\n  const ref = useRef(false);\n  useEffect(() => {\n    ref.current = true;\n  }, []);\n  return ref.current;\n};\nconst useDevice = deviceFromProps => {\n  const deviceFromContext = useContext(Context);\n  const getDevice = () => hyphenateKeys(deviceFromProps) || hyphenateKeys(deviceFromContext);\n  const [device, setDevice] = useState(getDevice);\n  useEffect(() => {\n    const newDevice = getDevice();\n    if (!shallowEqualObjects(device, newDevice)) {\n      setDevice(newDevice);\n    }\n  }, [deviceFromProps, deviceFromContext]);\n  return device;\n};\nconst useQuery = settings => {\n  const getQuery = () => makeQuery(settings);\n  const [query, setQuery] = useState(getQuery);\n  useEffect(() => {\n    const newQuery = getQuery();\n    if (query !== newQuery) {\n      setQuery(newQuery);\n    }\n  }, [settings]);\n  return query;\n};\nconst useMatchMedia = (query, device) => {\n  const getMatchMedia = () => matchMedia(query, device || {}, !!device);\n  const [mq, setMq] = useState(getMatchMedia);\n  const isUpdate = useIsUpdate();\n  useEffect(() => {\n    if (isUpdate) {\n      // skip on mounting, it has already been set\n      const newMq = getMatchMedia();\n      setMq(newMq);\n      return () => {\n        if (newMq) {\n          newMq.dispose();\n        }\n      };\n    }\n  }, [query, device]);\n  return mq;\n};\nconst useMatches = mediaQuery => {\n  const [matches, setMatches] = useState(mediaQuery.matches);\n  useEffect(() => {\n    const updateMatches = ev => {\n      setMatches(ev.matches);\n    };\n    mediaQuery.addListener(updateMatches);\n    setMatches(mediaQuery.matches);\n    return () => {\n      mediaQuery.removeListener(updateMatches);\n    };\n  }, [mediaQuery]);\n  return matches;\n};\nconst useMediaQuery = (settings, device, onChange) => {\n  const deviceSettings = useDevice(device);\n  const query = useQuery(settings);\n  if (!query) throw new Error('Invalid or missing MediaQuery!');\n  const mq = useMatchMedia(query, deviceSettings);\n  const matches = useMatches(mq);\n  const isUpdate = useIsUpdate();\n  useEffect(() => {\n    if (isUpdate && onChange) {\n      onChange(matches);\n    }\n  }, [matches]);\n  useEffect(() => () => {\n    if (mq) {\n      mq.dispose();\n    }\n  }, []);\n  return matches;\n};\n\n// ReactNode and ReactElement typings are a little funky for functional components, so the ReactElement cast is needed on the return\nconst MediaQuery = ({\n  children,\n  device,\n  onChange,\n  ...settings\n}) => {\n  const matches = useMediaQuery(settings, device, onChange);\n  if (typeof children === 'function') {\n    return children(matches);\n  }\n  return matches ? children : null;\n};\nexport { Context, MediaQuery as default, toQuery, useMediaQuery };","map":{"version":3,"sources":["../../src/mediaQuery.ts","../../src/toQuery.ts","../../src/Context.ts","../../src/useMediaQuery.ts","../../src/Component.ts"],"names":[],"mappings":"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","sourcesContent":["import { createContext, useRef, useEffect, useContext, useState } from 'react';\nimport matchMedia from 'matchmediaquery';\nimport hyphenate from 'hyphenate-style-name';\nimport { shallowEqualObjects } from 'shallow-equal';\nimport PropTypes from 'prop-types';\n\nconst stringOrNumber = PropTypes.oneOfType([PropTypes.string, PropTypes.number]);\n// media types\nconst types = {\n    all: PropTypes.bool,\n    grid: PropTypes.bool,\n    aural: PropTypes.bool,\n    braille: PropTypes.bool,\n    handheld: PropTypes.bool,\n    print: PropTypes.bool,\n    projection: PropTypes.bool,\n    screen: PropTypes.bool,\n    tty: PropTypes.bool,\n    tv: PropTypes.bool,\n    embossed: PropTypes.bool\n};\n// properties that match media queries\nconst matchers = {\n    orientation: PropTypes.oneOf(['portrait', 'landscape']),\n    scan: PropTypes.oneOf(['progressive', 'interlace']),\n    aspectRatio: PropTypes.string,\n    deviceAspectRatio: PropTypes.string,\n    height: stringOrNumber,\n    deviceHeight: stringOrNumber,\n    width: stringOrNumber,\n    deviceWidth: stringOrNumber,\n    color: PropTypes.bool,\n    colorIndex: PropTypes.bool,\n    monochrome: PropTypes.bool,\n    resolution: stringOrNumber,\n    type: Object.keys(types)\n};\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst { type, ...featureMatchers } = matchers;\n// media features\nconst features = {\n    minAspectRatio: PropTypes.string,\n    maxAspectRatio: PropTypes.string,\n    minDeviceAspectRatio: PropTypes.string,\n    maxDeviceAspectRatio: PropTypes.string,\n    minHeight: stringOrNumber,\n    maxHeight: stringOrNumber,\n    minDeviceHeight: stringOrNumber,\n    maxDeviceHeight: stringOrNumber,\n    minWidth: stringOrNumber,\n    maxWidth: stringOrNumber,\n    minDeviceWidth: stringOrNumber,\n    maxDeviceWidth: stringOrNumber,\n    minColor: PropTypes.number,\n    maxColor: PropTypes.number,\n    minColorIndex: PropTypes.number,\n    maxColorIndex: PropTypes.number,\n    minMonochrome: PropTypes.number,\n    maxMonochrome: PropTypes.number,\n    minResolution: stringOrNumber,\n    maxResolution: stringOrNumber,\n    ...featureMatchers\n};\nconst all = { ...types, ...features };\nvar mq = {\n    all: all,\n    types: types,\n    matchers: matchers,\n    features: features\n};\n\nconst negate = (cond) => `not ${cond}`;\nconst keyVal = (k, v) => {\n    const realKey = hyphenate(k);\n    // px shorthand\n    if (typeof v === 'number') {\n        v = `${v}px`;\n    }\n    if (v === true) {\n        return realKey;\n    }\n    if (v === false) {\n        return negate(realKey);\n    }\n    return `(${realKey}: ${v})`;\n};\nconst join = (conds) => conds.join(' and ');\nconst toQuery = (obj) => {\n    const rules = [];\n    Object.keys(mq.all).forEach((k) => {\n        const v = obj[k];\n        if (v != null) {\n            rules.push(keyVal(k, v));\n        }\n    });\n    return join(rules);\n};\n\nconst Context = createContext(undefined);\n\nconst makeQuery = (settings) => settings.query || toQuery(settings);\nconst hyphenateKeys = (obj) => {\n    if (!obj)\n        return undefined;\n    const keys = Object.keys(obj);\n    return keys.reduce((result, key) => {\n        result[hyphenate(key)] = obj[key];\n        return result;\n    }, {});\n};\nconst useIsUpdate = () => {\n    const ref = useRef(false);\n    useEffect(() => {\n        ref.current = true;\n    }, []);\n    return ref.current;\n};\nconst useDevice = (deviceFromProps) => {\n    const deviceFromContext = useContext(Context);\n    const getDevice = () => hyphenateKeys(deviceFromProps) || hyphenateKeys(deviceFromContext);\n    const [device, setDevice] = useState(getDevice);\n    useEffect(() => {\n        const newDevice = getDevice();\n        if (!shallowEqualObjects(device, newDevice)) {\n            setDevice(newDevice);\n        }\n    }, [deviceFromProps, deviceFromContext]);\n    return device;\n};\nconst useQuery = (settings) => {\n    const getQuery = () => makeQuery(settings);\n    const [query, setQuery] = useState(getQuery);\n    useEffect(() => {\n        const newQuery = getQuery();\n        if (query !== newQuery) {\n            setQuery(newQuery);\n        }\n    }, [settings]);\n    return query;\n};\nconst useMatchMedia = (query, device) => {\n    const getMatchMedia = () => matchMedia(query, device || {}, !!device);\n    const [mq, setMq] = useState(getMatchMedia);\n    const isUpdate = useIsUpdate();\n    useEffect(() => {\n        if (isUpdate) {\n            // skip on mounting, it has already been set\n            const newMq = getMatchMedia();\n            setMq(newMq);\n            return () => {\n                if (newMq) {\n                    newMq.dispose();\n                }\n            };\n        }\n    }, [query, device]);\n    return mq;\n};\nconst useMatches = (mediaQuery) => {\n    const [matches, setMatches] = useState(mediaQuery.matches);\n    useEffect(() => {\n        const updateMatches = (ev) => {\n            setMatches(ev.matches);\n        };\n        mediaQuery.addListener(updateMatches);\n        setMatches(mediaQuery.matches);\n        return () => {\n            mediaQuery.removeListener(updateMatches);\n        };\n    }, [mediaQuery]);\n    return matches;\n};\nconst useMediaQuery = (settings, device, onChange) => {\n    const deviceSettings = useDevice(device);\n    const query = useQuery(settings);\n    if (!query)\n        throw new Error('Invalid or missing MediaQuery!');\n    const mq = useMatchMedia(query, deviceSettings);\n    const matches = useMatches(mq);\n    const isUpdate = useIsUpdate();\n    useEffect(() => {\n        if (isUpdate && onChange) {\n            onChange(matches);\n        }\n    }, [matches]);\n    useEffect(() => () => {\n        if (mq) {\n            mq.dispose();\n        }\n    }, []);\n    return matches;\n};\n\n// ReactNode and ReactElement typings are a little funky for functional components, so the ReactElement cast is needed on the return\nconst MediaQuery = ({ children, device, onChange, ...settings }) => {\n    const matches = useMediaQuery(settings, device, onChange);\n    if (typeof children === 'function') {\n        return children(matches);\n    }\n    return matches ? children : null;\n};\n\nexport { Context, MediaQuery as default, toQuery, useMediaQuery };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}